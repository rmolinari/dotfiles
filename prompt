#
# Set up my prompt

# When we are in a git-controlled directory the prompt includes the current
# git branch and status.  In directories not in a git project there is no
# such representation.

function __prompt_exit_val
{
    local val=$?
    if [[ $val != 0 ]]
    then
        printf "${1:- (%s)}" "$val"
    fi
}


function setprompt 
{
    ##
    # Git decoration
    export GIT_PS1_SHOWDIRTYSTATE=true
    export GIT_PS1_SHOWSTASHSTATE=true
    export GIT_PS1_SHOWUNTRACKEDFILES=true

    function __prompt_escape {
        echo "\[$1\]"
    }

    # We use tput for portability.  See 'man tput' and 'man 5 terminfo' for
    # details on what is possible.
    function fg {
        # sgr0 clears attributes; setaf sets foreground color
        __prompt_escape $(tput sgr0; tput setaf $1)
    }

    function bg {
        # setab sets the background color
        __prompt_escape $(tput setab $1)
    }
    
    local BOLD=$(__prompt_escape $(tput bold))
    local RESET_ALL=$(__prompt_escape $(tput sgr0))

    ##
    # Define local variables for each color and bold/bright: RED, B_RED, GREEN, B_GREEN, etc
    # Each of these clears all text attributes first.  In particular they clear the
    # background color so you'll need to keep track of that separately.
    #
    # We also define BG_<color> to set the background in each case.
    #
    for pair in BLACK_0 RED_1 GREEN_2 BROWN_3 BLUE_4 PURPLE_5 CYAN_6 GRAY_7
    do
        local col=${pair%_*}
        local code=${pair#*_}
        eval "local ${col}=\$(fg ${code})"
        eval "local B_${col}=\$(fg ${code})\${BOLD}"
        eval "local BG_${col}=\$(bg ${code})"
    done

    local BASE=${BLUE}

    local exit_val="\$(__prompt_exit_val '${RED}%s ${BASE}')"
    local git_status="\$(__git_ps1 ' ${BROWN}[%s]${BASE}')"

    PS1="${BASE}[${exit_val}\u:\w]${git_status}\n\$(date +%H:%M:%S) ${RESET_ALL}"

    unset -f __prompt_escape fg bg
}

setprompt
unset -f setprompt
